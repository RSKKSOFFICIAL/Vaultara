{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-037363c64f9b5e6c1497b8db3c3e06e1c225cd06",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/VaultaraInheritance.sol": "project/contracts/VaultaraInheritance.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/access/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
      },
      "project/contracts/VaultaraInheritance.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\n/**\r\n * @title VaultaraInheritance\r\n * @dev Self-sovereign crypto inheritance wallet with heartbeat mechanism\r\n * @notice Ensures digital assets are transferred to beneficiaries if owner becomes inactive\r\n * @author Ravi Shankar Kumar\r\n */\r\ncontract VaultaraInheritance is ReentrancyGuard, Ownable {\r\n    // ============ State Variables ============\r\n\r\n    /// @notice Heartbeat interval in seconds (e.g., 7 days = 604800 seconds)\r\n    uint256 public heartbeatInterval;\r\n\r\n    /// @notice Timestamp of the last heartbeat\r\n    uint256 public lastHeartbeat;\r\n\r\n    /// @notice Flag to check if vault is active\r\n    bool public isActive;\r\n\r\n    /// @notice Struct to store beneficiary information\r\n    struct Beneficiary {\r\n        address beneficiaryAddress;\r\n        uint256 sharePercentage; // Percentage * 100 (e.g., 50.5% = 5050)\r\n        string encryptedMetadata; // Encrypted data from Lit Protocol\r\n        bool isActive;\r\n    }\r\n\r\n    /// @notice Array of all beneficiaries\r\n    Beneficiary[] public beneficiaries;\r\n\r\n    /// @notice Mapping to check if an address is already a beneficiary\r\n    mapping(address => bool) public isBeneficiary;\r\n\r\n    /// @notice Total share percentage (must equal 10000 = 100%)\r\n    uint256 public totalSharePercentage;\r\n\r\n    /// @notice Flag to prevent multiple inheritance triggers\r\n    bool public inheritanceTriggered;\r\n\r\n    // ============ Events ============\r\n\r\n    event VaultInitialized(address indexed owner, uint256 heartbeatInterval);\r\n    event HeartbeatSent(address indexed owner, uint256 timestamp);\r\n    event BeneficiaryAdded(\r\n        address indexed beneficiary,\r\n        uint256 sharePercentage\r\n    );\r\n    event BeneficiaryUpdated(\r\n        address indexed beneficiary,\r\n        uint256 newSharePercentage\r\n    );\r\n    event BeneficiaryRemoved(address indexed beneficiary);\r\n    event HeartbeatIntervalUpdated(uint256 newInterval);\r\n    event InheritanceTriggered(uint256 timestamp);\r\n    event FundsTransferred(address indexed beneficiary, uint256 amount);\r\n    event VaultDeactivated(address indexed owner);\r\n\r\n    // ============ Errors ============\r\n\r\n    error VaultNotActive();\r\n    error VaultAlreadyActive();\r\n    error InvalidHeartbeatInterval();\r\n    error HeartbeatStillValid();\r\n    error InvalidBeneficiary();\r\n    error BeneficiaryAlreadyExists();\r\n    error BeneficiaryNotFound();\r\n    error InvalidSharePercentage();\r\n    error TotalShareMustBe100Percent();\r\n    error InheritanceAlreadyTriggered();\r\n    error NoFundsToTransfer();\r\n    error TransferFailed();\r\n    error NoBeneficiaries();\r\n\r\n    // ============ Modifiers ============\r\n\r\n    modifier onlyWhenActive() {\r\n        if (!isActive) revert VaultNotActive();\r\n        _;\r\n    }\r\n\r\n    modifier onlyWhenInactive() {\r\n        if (isActive) revert VaultAlreadyActive();\r\n        _;\r\n    }\r\n\r\n    modifier notTriggered() {\r\n        if (inheritanceTriggered) revert InheritanceAlreadyTriggered();\r\n        _;\r\n    }\r\n\r\n    // ============ Constructor ============\r\n\r\n    /**\r\n     * @dev Initializes the contract, setting the deployer as owner\r\n     */\r\n    constructor() Ownable(msg.sender) {\r\n        isActive = false;\r\n        inheritanceTriggered = false;\r\n    }\r\n\r\n    // ============ Owner Functions ============\r\n\r\n    /**\r\n     * @notice Initializes the vault with heartbeat interval\r\n     * @param _heartbeatInterval Time in seconds between required heartbeats (min: 1 day, max: 365 days)\r\n     */\r\n    function initializeVault(\r\n        uint256 _heartbeatInterval\r\n    ) external onlyOwner onlyWhenInactive {\r\n        if (_heartbeatInterval < 1 days || _heartbeatInterval > 365 days) {\r\n            revert InvalidHeartbeatInterval();\r\n        }\r\n\r\n        heartbeatInterval = _heartbeatInterval;\r\n        lastHeartbeat = block.timestamp;\r\n        isActive = true;\r\n\r\n        emit VaultInitialized(msg.sender, _heartbeatInterval);\r\n        emit HeartbeatSent(msg.sender, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Sends a heartbeat to prove owner is alive\r\n     */\r\n    function sendHeartbeat() external onlyOwner onlyWhenActive notTriggered {\r\n        lastHeartbeat = block.timestamp;\r\n        emit HeartbeatSent(msg.sender, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Adds a new beneficiary with encrypted metadata\r\n     * @param _beneficiary Address of the beneficiary\r\n     * @param _sharePercentage Share percentage * 100 (e.g., 50.5% = 5050)\r\n     * @param _encryptedMetadata Encrypted data from Lit Protocol\r\n     */\r\n    function addBeneficiary(\r\n        address _beneficiary,\r\n        uint256 _sharePercentage,\r\n        string calldata _encryptedMetadata\r\n    ) external onlyOwner onlyWhenActive notTriggered {\r\n        if (_beneficiary == address(0) || _beneficiary == owner()) {\r\n            revert InvalidBeneficiary();\r\n        }\r\n        if (isBeneficiary[_beneficiary]) {\r\n            revert BeneficiaryAlreadyExists();\r\n        }\r\n        if (_sharePercentage == 0 || _sharePercentage > 10000) {\r\n            revert InvalidSharePercentage();\r\n        }\r\n\r\n        beneficiaries.push(\r\n            Beneficiary({\r\n                beneficiaryAddress: _beneficiary,\r\n                sharePercentage: _sharePercentage,\r\n                encryptedMetadata: _encryptedMetadata,\r\n                isActive: true\r\n            })\r\n        );\r\n\r\n        isBeneficiary[_beneficiary] = true;\r\n        totalSharePercentage += _sharePercentage;\r\n\r\n        if (totalSharePercentage > 10000) {\r\n            revert TotalShareMustBe100Percent();\r\n        }\r\n\r\n        emit BeneficiaryAdded(_beneficiary, _sharePercentage);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates an existing beneficiary's share percentage\r\n     * @param _beneficiary Address of the beneficiary\r\n     * @param _newSharePercentage New share percentage * 100\r\n     */\r\n    function updateBeneficiary(\r\n        address _beneficiary,\r\n        uint256 _newSharePercentage\r\n    ) external onlyOwner onlyWhenActive notTriggered {\r\n        if (!isBeneficiary[_beneficiary]) {\r\n            revert BeneficiaryNotFound();\r\n        }\r\n        if (_newSharePercentage == 0 || _newSharePercentage > 10000) {\r\n            revert InvalidSharePercentage();\r\n        }\r\n\r\n        for (uint256 i = 0; i < beneficiaries.length; i++) {\r\n            if (\r\n                beneficiaries[i].beneficiaryAddress == _beneficiary &&\r\n                beneficiaries[i].isActive\r\n            ) {\r\n                uint256 oldShare = beneficiaries[i].sharePercentage;\r\n                beneficiaries[i].sharePercentage = _newSharePercentage;\r\n\r\n                totalSharePercentage =\r\n                    totalSharePercentage -\r\n                    oldShare +\r\n                    _newSharePercentage;\r\n\r\n                if (totalSharePercentage > 10000) {\r\n                    revert TotalShareMustBe100Percent();\r\n                }\r\n\r\n                emit BeneficiaryUpdated(_beneficiary, _newSharePercentage);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Removes a beneficiary\r\n     * @param _beneficiary Address of the beneficiary to remove\r\n     */\r\n    function removeBeneficiary(\r\n        address _beneficiary\r\n    ) external onlyOwner onlyWhenActive notTriggered {\r\n        if (!isBeneficiary[_beneficiary]) {\r\n            revert BeneficiaryNotFound();\r\n        }\r\n\r\n        for (uint256 i = 0; i < beneficiaries.length; i++) {\r\n            if (\r\n                beneficiaries[i].beneficiaryAddress == _beneficiary &&\r\n                beneficiaries[i].isActive\r\n            ) {\r\n                totalSharePercentage -= beneficiaries[i].sharePercentage;\r\n                beneficiaries[i].isActive = false;\r\n                isBeneficiary[_beneficiary] = false;\r\n\r\n                emit BeneficiaryRemoved(_beneficiary);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the heartbeat interval\r\n     * @param _newInterval New interval in seconds\r\n     */\r\n    function updateHeartbeatInterval(\r\n        uint256 _newInterval\r\n    ) external onlyOwner onlyWhenActive notTriggered {\r\n        if (_newInterval < 1 days || _newInterval > 365 days) {\r\n            revert InvalidHeartbeatInterval();\r\n        }\r\n\r\n        heartbeatInterval = _newInterval;\r\n        emit HeartbeatIntervalUpdated(_newInterval);\r\n    }\r\n\r\n    /**\r\n     * @notice Deactivates the vault (owner can withdraw funds)\r\n     */\r\n    function deactivateVault() external onlyOwner onlyWhenActive notTriggered {\r\n        isActive = false;\r\n        emit VaultDeactivated(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Owner can withdraw funds when vault is deactivated\r\n     */\r\n    function withdrawFunds() external onlyOwner nonReentrant {\r\n        if (isActive) revert VaultNotActive();\r\n\r\n        uint256 balance = address(this).balance;\r\n        if (balance == 0) revert NoFundsToTransfer();\r\n\r\n        (bool success, ) = payable(owner()).call{value: balance}(\"\");\r\n        if (!success) revert TransferFailed();\r\n    }\r\n\r\n    // ============ Public Functions ============\r\n\r\n    /**\r\n     * @notice Checks if heartbeat has expired\r\n     * @return bool True if heartbeat has expired\r\n     */\r\n    function isHeartbeatExpired() public view returns (bool) {\r\n        if (!isActive) return false;\r\n        return (block.timestamp > lastHeartbeat + heartbeatInterval);\r\n    }\r\n\r\n    /**\r\n     * @notice Triggers inheritance and transfers funds to beneficiaries\r\n     * @dev Can be called by anyone if heartbeat has expired\r\n     */\r\n    function triggerInheritance()\r\n        external\r\n        nonReentrant\r\n        onlyWhenActive\r\n        notTriggered\r\n    {\r\n        if (!isHeartbeatExpired()) {\r\n            revert HeartbeatStillValid();\r\n        }\r\n\r\n        if (beneficiaries.length == 0) {\r\n            revert NoBeneficiaries();\r\n        }\r\n\r\n        if (totalSharePercentage != 10000) {\r\n            revert TotalShareMustBe100Percent();\r\n        }\r\n\r\n        inheritanceTriggered = true;\r\n        isActive = false;\r\n\r\n        emit InheritanceTriggered(block.timestamp);\r\n\r\n        uint256 balance = address(this).balance;\r\n        if (balance == 0) revert NoFundsToTransfer();\r\n\r\n        // Transfer funds to beneficiaries\r\n        for (uint256 i = 0; i < beneficiaries.length; i++) {\r\n            if (beneficiaries[i].isActive) {\r\n                uint256 amount = (balance * beneficiaries[i].sharePercentage) /\r\n                    10000;\r\n\r\n                if (amount > 0) {\r\n                    (bool success, ) = payable(\r\n                        beneficiaries[i].beneficiaryAddress\r\n                    ).call{value: amount}(\"\");\r\n                    if (!success) revert TransferFailed();\r\n\r\n                    emit FundsTransferred(\r\n                        beneficiaries[i].beneficiaryAddress,\r\n                        amount\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Gets all active beneficiaries\r\n     * @return Array of active beneficiaries\r\n     */\r\n    function getActiveBeneficiaries()\r\n        external\r\n        view\r\n        returns (Beneficiary[] memory)\r\n    {\r\n        uint256 activeCount = 0;\r\n\r\n        for (uint256 i = 0; i < beneficiaries.length; i++) {\r\n            if (beneficiaries[i].isActive) {\r\n                activeCount++;\r\n            }\r\n        }\r\n\r\n        Beneficiary[] memory activeBeneficiaries = new Beneficiary[](\r\n            activeCount\r\n        );\r\n        uint256 currentIndex = 0;\r\n\r\n        for (uint256 i = 0; i < beneficiaries.length; i++) {\r\n            if (beneficiaries[i].isActive) {\r\n                activeBeneficiaries[currentIndex] = beneficiaries[i];\r\n                currentIndex++;\r\n            }\r\n        }\r\n\r\n        return activeBeneficiaries;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets time remaining until heartbeat expires\r\n     * @return uint256 Seconds remaining (0 if expired)\r\n     */\r\n    function getTimeUntilExpiry() external view returns (uint256) {\r\n        if (!isActive || isHeartbeatExpired()) {\r\n            return 0;\r\n        }\r\n        return (lastHeartbeat + heartbeatInterval) - block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets total number of beneficiaries (including inactive)\r\n     * @return uint256 Total beneficiary count\r\n     */\r\n    function getBeneficiaryCount() external view returns (uint256) {\r\n        return beneficiaries.length;\r\n    }\r\n\r\n    // ============ Receive Function ============\r\n\r\n    /**\r\n     * @notice Allows contract to receive ETH\r\n     */\r\n    receive() external payable {}\r\n\r\n    /**\r\n     * @notice Fallback function\r\n     */\r\n    fallback() external payable {}\r\n}\r\n"
      }
    }
  }
}